import { themes } from 'mdx-deck';
import { CodeSurfer } from 'code-surfer';
import { vsDark } from "@code-surfer/themes"
import { default as Provider } from "./components/custom_provider.js"
import "prismjs/components/prism-rust"
import "prismjs/components/prism-toml"
import "prismjs/components/prism-cmake"

export const theme = themes.future
export const provider = Provider


import rust_logo from './resources/rust_logo.png';
import meme from './resources/meme.png'
import clones from './resources/clones.png'

# Welcome to 
# The Lessons from Rust for C++ Developers

Hello my name is Erdem and I'm a C++ Developer (Believe me I _double_ checked).

Everything on this presentation including these slides & code examples can be found at my github. 

[my github](http://github.com/erdemu)

---

## Agenda for today

1. What is Rust ? Why should I care about it ?

2. What is this meeting ? What should I expect ?

3. Cargo ( Package manager )

4. Code generation you love but built-in

5. Linear types

6. Some short information about the other ideas in the language

---

## What is Rust ? 

<img src={rust_logo} 
style={{
    width: '400px',
    height: '400px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  }}
/>
<Steps>
    <li>A sort of new (developed in 2010s) systems programming language.</li>
    <li>Developed by mozilla</li>
    <li>It has been voted 4 consequtive times as the most loved language of the year</li>
    <li>Main focus is on safety and multithreaded systems programming</li>
    <li>It has been designed to mitigate pain points in older system programming languages</li>
    <li>Used by mozilla, microsoft, dropbox on low level systems</li>
    <li>It's compiler is backed by LLVM so has many targets (Yes including embedded microcontrollers) </li>
</Steps>

---

## Why you should care about the Rust ?

<Steps>
    <li>C/C++ are really really cool languages. That's why they are still here</li>
    <li>But they desingned in a different era</li>
    <li>We are not programming like when we were back then</li>
    <li>It has been desinged with current facilities in mind.</li>
    <li>Same facilities and values as C++ (Only pay for what you use etc.)</li>
    <li>It has been desinged by people like us to relieve some pain</li>
    <li>Simple bugs cost much</li>
</Steps>

---

## What is this meeting ? What should I expect ?

<Steps>
    <li>Okay okay, I am admitting that I am a bit of in love with this language.</li>
    <li>... and maybe a bit of envy of its features</li>
    <li>This meeting is about some features in rust that I personally think very good</li>
    <li>And I want to show them to you and maybe try to do something similiar in modern C++.</li>
    <li>If you are interested in Rust and thinking this is a Rust 101 i'm sorry but this is not it.</li>
    <li>But I hope there are still much quality content here, so don't leave yet</li>
</Steps>

---

# I am envy of Cargo 
# ( Their package manager )

---

## I am envy of Cargo ( Their package manager )

<Steps>
    <li>Remember when I said there are features designed for our current way of programming</li>
    <li>Package managers are little programs that can download and install libraries developed by someone else for you</li>
    <li>We don't have anything like that (as a standard) in C++</li>
    <li>With Cargo you can do some interesting (non-centralised) stuff</li>
</Steps>

---

## I am envy of Cargo ( Their package manager )

This is config.yml file for a Rust module

<CodeSurfer theme={vsDark}>

```toml 
[package]
name = "ggez"
description = "A lightweight game framework for making 2D games with minimum friction, inspired by Love2D."
version = "0.5.1"
homepage = "http://ggez.rs"
repository = "https://github.com/ggez/ggez"
documentation = "https://docs.rs/ggez"
keywords = ["ggez", "graphics", "2D", "game", "engine"]
authors = [
   "Rafael Epplee <raffomania@gmail.com>",
   "Sven-Hendrik Haase <svenstaro@gmail.com>",
   "Simon Heath <icefoxen@gmail.com>",
]

[dependencies]
gfx = "0.18"
gfx_core = "0.9"
gfx_device_gl = "0.16"
glyph_brush = "0.5"
gfx_window_glutin = "0.30"
```

```toml 1,15
[package]
name = "ggez"
description = "A lightweight game framework for making 2D games with minimum friction, inspired by Love2D."
version = "0.5.1"
homepage = "http://ggez.rs"
repository = "https://github.com/ggez/ggez"
documentation = "https://docs.rs/ggez"
keywords = ["ggez", "graphics", "2D", "game", "engine"]
authors = [
   "Rafael Epplee <raffomania@gmail.com>",
   "Sven-Hendrik Haase <svenstaro@gmail.com>",
   "Simon Heath <icefoxen@gmail.com>",
]

[dependencies]
gfx = "0.18"
gfx_core = "0.9"
gfx_device_gl = "0.16"
glyph_brush = "0.5"
gfx_window_glutin = "0.30"
```

```toml 
[package]
name = "ggez"
description = "A lightweight game framework for making 2D games with minimum friction, inspired by Love2D."
version = "0.5.1"
homepage = "http://ggez.rs"
repository = "https://github.com/ggez/ggez"
documentation = "https://docs.rs/ggez"
keywords = ["ggez", "graphics", "2D", "game", "engine"]
authors = [
   "Rafael Epplee <raffomania@gmail.com>",
   "Sven-Hendrik Haase <svenstaro@gmail.com>",
   "Simon Heath <icefoxen@gmail.com>",
]

[dependencies]
gfx = "0.18"
gfx_core = "0.9"
gfx_device_gl = "0.16"
glyph_brush = "0.5"
gfx_window_glutin = "0.30"
```

```toml 2
[package]
name = "ggez"
description = "A lightweight game framework for making 2D games with minimum friction, inspired by Love2D."
version = "0.5.1"
homepage = "http://ggez.rs"
repository = "https://github.com/ggez/ggez"
documentation = "https://docs.rs/ggez"
keywords = ["ggez", "graphics", "2D", "game", "engine"]
authors = [
   "Rafael Epplee <raffomania@gmail.com>",
   "Sven-Hendrik Haase <svenstaro@gmail.com>",
   "Simon Heath <icefoxen@gmail.com>",
]

[dependencies]
gfx = "0.18"
gfx_core = "0.9"
gfx_device_gl = "0.16"
glyph_brush = "0.5"
gfx_window_glutin = "0.30"
```

```toml 3:14
[package]
name = "ggez"
description = "A lightweight game framework for making 2D games with minimum friction, inspired by Love2D."
version = "0.5.1"
homepage = "http://ggez.rs"
repository = "https://github.com/ggez/ggez"
documentation = "https://docs.rs/ggez"
keywords = ["ggez", "graphics", "2D", "game", "engine"]
authors = [
   "Rafael Epplee <raffomania@gmail.com>",
   "Sven-Hendrik Haase <svenstaro@gmail.com>",
   "Simon Heath <icefoxen@gmail.com>",
]

[dependencies]
gfx = "0.18"
gfx_core = "0.9"
gfx_device_gl = "0.16"
glyph_brush = "0.5"
gfx_window_glutin = "0.30"
```

```toml 16:21
[package]
name = "ggez"
description = "A lightweight game framework for making 2D games with minimum friction, inspired by Love2D."
version = "0.5.1"
homepage = "http://ggez.rs"
repository = "https://github.com/ggez/ggez"
documentation = "https://docs.rs/ggez"
keywords = ["ggez", "graphics", "2D", "game", "engine"]
authors = [
   "Rafael Epplee <raffomania@gmail.com>",
   "Sven-Hendrik Haase <svenstaro@gmail.com>",
   "Simon Heath <icefoxen@gmail.com>",
]

[dependencies]
gfx = "0.18"
gfx_core = "0.9"
gfx_device_gl = "0.16"
glyph_brush = "0.5"
gfx_window_glutin = "0.30"
```

```toml 16[6:15]
[package]
name = "ggez"
description = "A lightweight game framework for making 2D games with minimum friction, inspired by Love2D."
version = "0.5.1"
homepage = "http://ggez.rs"
repository = "https://github.com/ggez/ggez"
documentation = "https://docs.rs/ggez"
keywords = ["ggez", "graphics", "2D", "game", "engine"]
authors = [
   "Rafael Epplee <raffomania@gmail.com>",
   "Sven-Hendrik Haase <svenstaro@gmail.com>",
   "Simon Heath <icefoxen@gmail.com>",
]

[dependencies]
gfx = "0.18"
gfx_core = "0.9"
gfx_device_gl = "0.16"
glyph_brush = "0.5"
gfx_window_glutin = "0.30"
```

```toml 16[6:30]
[package]
name = "ggez"
description = "A lightweight game framework for making 2D games with minimum friction, inspired by Love2D."
version = "0.5.1"
homepage = "http://ggez.rs"
repository = "https://github.com/ggez/ggez"
documentation = "https://docs.rs/ggez"
keywords = ["ggez", "graphics", "2D", "game", "engine"]
authors = [
   "Rafael Epplee <raffomania@gmail.com>",
   "Sven-Hendrik Haase <svenstaro@gmail.com>",
   "Simon Heath <icefoxen@gmail.com>",
]

[dependencies]
gfx = "^0.18" Until the 1.00
gfx_core = "0.9"
gfx_device_gl = "0.16"
glyph_brush = "0.5"
gfx_window_glutin = "0.30"
```

```toml 17:18
[package]
name = "ggez"
description = "A lightweight game framework for making 2D games with minimum friction, inspired by Love2D."
version = "0.5.1"
homepage = "http://ggez.rs"
repository = "https://github.com/ggez/ggez"
documentation = "https://docs.rs/ggez"
keywords = ["ggez", "graphics", "2D", "game", "engine"]
authors = [
   "Rafael Epplee <raffomania@gmail.com>",
   "Sven-Hendrik Haase <svenstaro@gmail.com>",
   "Simon Heath <icefoxen@gmail.com>",
]

[dependencies]
gfx = "^0.18"
some-crate = { version = "1.0", registry = "my-registry" }
rand = { git = "https://github.com/rust-lang-nursery/rand" }
gfx_core = "0.9"
gfx_device_gl = "0.16"
glyph_brush = "0.5"
gfx_window_glutin = "0.30"
```

```toml 17:18
[package]
name = "ggez"
description = "A lightweight game framework for making 2D games with minimum friction, inspired by Love2D."
version = "0.5.1"
homepage = "http://ggez.rs"
repository = "https://github.com/ggez/ggez"
documentation = "https://docs.rs/ggez"
keywords = ["ggez", "graphics", "2D", "game", "engine"]
authors = [
   "Rafael Epplee <raffomania@gmail.com>",
   "Sven-Hendrik Haase <svenstaro@gmail.com>",
   "Simon Heath <icefoxen@gmail.com>",
]

[dependencies]
gfx = "^0.18"
some-crate = { version = "1.0", registry = "my-registry" }
rand = { git = "https://github.com/rust-lang-nursery/rand", branch="someExperimentalBranch" }
gfx_core = "0.9"
gfx_device_gl = "0.16"
glyph_brush = "0.5"
gfx_window_glutin = "0.30"
```

</CodeSurfer>

---

## I am envy of Cargo ( Their package manager )

<Steps>
    <li>These are all very good but how we can achieve something similiar in C++ ?</li>
    <li>For the reminder of this section I will try to create same thing with using Cmake</li>
    <li>Rationale : Cmake is the best thing we have in C/C++ that remotely resembles a standard</li>
    <li>Cmake is a rich language/meta build system. We can achieve this easily by writing our own cmake scripts</li>
    <li>Ideally we really don't want to write custom scripts</li>
    <li>Who needs more stuff to maintain ?</li>
    <li>Luckly Cmake world is good enough to fulfill our desires</li>
</Steps>

---

## I am envy of Cargo 

<CodeSurfer theme={vsDark}>

```cmake
cmake_minimum_required(VERSION 3.18)

project(cpm_example)

set(CMAKE_CXX_STANDARD 17)

set(CPM_DOWNLOAD_VERSION 0.27.2) 
set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")

if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
    message(STATUS "Downloading CPM.cmake")
    file(DOWNLOAD https://github.com/TheLartians/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake ${CPM_DOWNLOAD_LOCATION})
endif()

include(${CPM_DOWNLOAD_LOCATION})

CPMAddPackage(
    NAME spdlog
    GITHUB_REPOSITORY gabime/spdlog
    VERSION 1.7.0)
    
add_executable(cpm_example src/main.cpp)

target_link_libraries(cpm_example
    spdlog)
```

```cmake 1:6
cmake_minimum_required(VERSION 3.18)

project(cpm_example)

set(CMAKE_CXX_STANDARD 17)

set(CPM_DOWNLOAD_VERSION 0.27.2) 
set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")

if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
    message(STATUS "Downloading CPM.cmake")
    file(DOWNLOAD https://github.com/TheLartians/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake ${CPM_DOWNLOAD_LOCATION})
endif()

include(${CPM_DOWNLOAD_LOCATION})

CPMAddPackage(
    NAME spdlog
    GITHUB_REPOSITORY gabime/spdlog
    VERSION 1.7.0)
    
add_executable(cpm_example src/main.cpp)

target_link_libraries(cpm_example
    spdlog)
```

```cmake 7:8
cmake_minimum_required(VERSION 3.18)

project(cpm_example)

set(CMAKE_CXX_STANDARD 17)

set(CPM_DOWNLOAD_VERSION 0.27.2) 
set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")

if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
    message(STATUS "Downloading CPM.cmake")
    file(DOWNLOAD https://github.com/TheLartians/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake ${CPM_DOWNLOAD_LOCATION})
endif()

include(${CPM_DOWNLOAD_LOCATION})

CPMAddPackage(
    NAME spdlog
    GITHUB_REPOSITORY gabime/spdlog
    VERSION 1.7.0)
    
add_executable(cpm_example src/main.cpp)

target_link_libraries(cpm_example
    spdlog)
```

```cmake 10
cmake_minimum_required(VERSION 3.18)

project(cpm_example)

set(CMAKE_CXX_STANDARD 17)

set(CPM_DOWNLOAD_VERSION 0.27.2) 
set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")

if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
    message(STATUS "Downloading CPM.cmake")
    file(DOWNLOAD https://github.com/TheLartians/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake ${CPM_DOWNLOAD_LOCATION})
endif()

include(${CPM_DOWNLOAD_LOCATION})

CPMAddPackage(
    NAME spdlog
    GITHUB_REPOSITORY gabime/spdlog
    VERSION 1.7.0)
    
add_executable(cpm_example src/main.cpp)

target_link_libraries(cpm_example
    spdlog)
```

```cmake 12
cmake_minimum_required(VERSION 3.18)

project(cpm_example)

set(CMAKE_CXX_STANDARD 17)

set(CPM_DOWNLOAD_VERSION 0.27.2) 
set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")

if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
    message(STATUS "Downloading CPM.cmake")
    file(DOWNLOAD https://github.com/TheLartians/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake ${CPM_DOWNLOAD_LOCATION})
endif()

include(${CPM_DOWNLOAD_LOCATION})

CPMAddPackage(
    NAME spdlog
    GITHUB_REPOSITORY gabime/spdlog
    VERSION 1.7.0)
    
add_executable(cpm_example src/main.cpp)

target_link_libraries(cpm_example
    spdlog)
```

```cmake 15
cmake_minimum_required(VERSION 3.18)

project(cpm_example)

set(CMAKE_CXX_STANDARD 17)

set(CPM_DOWNLOAD_VERSION 0.27.2) 
set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")

if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
    message(STATUS "Downloading CPM.cmake")
    file(DOWNLOAD https://github.com/TheLartians/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake ${CPM_DOWNLOAD_LOCATION})
endif()

include(${CPM_DOWNLOAD_LOCATION})

CPMAddPackage(
    NAME spdlog
    GITHUB_REPOSITORY gabime/spdlog
    VERSION 1.7.0)
    
add_executable(cpm_example src/main.cpp)

target_link_libraries(cpm_example
    spdlog)
```


```cmake 17:20
cmake_minimum_required(VERSION 3.18)

project(cpm_example)

set(CMAKE_CXX_STANDARD 17)

set(CPM_DOWNLOAD_VERSION 0.27.2) 
set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")

if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
    message(STATUS "Downloading CPM.cmake")
    file(DOWNLOAD https://github.com/TheLartians/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake ${CPM_DOWNLOAD_LOCATION})
endif()

include(${CPM_DOWNLOAD_LOCATION})

CPMAddPackage(
    NAME spdlog
    GITHUB_REPOSITORY gabime/spdlog
    VERSION 1.7.0)
    
add_executable(cpm_example src/main.cpp)

target_link_libraries(cpm_example
    spdlog)
```

```cmake 22
cmake_minimum_required(VERSION 3.18)

project(cpm_example)

set(CMAKE_CXX_STANDARD 17)

set(CPM_DOWNLOAD_VERSION 0.27.2) 
set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")

if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
    message(STATUS "Downloading CPM.cmake")
    file(DOWNLOAD https://github.com/TheLartians/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake ${CPM_DOWNLOAD_LOCATION})
endif()

include(${CPM_DOWNLOAD_LOCATION})

CPMAddPackage(
    NAME spdlog
    GITHUB_REPOSITORY gabime/spdlog
    VERSION 1.7.0)
    
add_executable(cpm_example src/main.cpp)

target_link_libraries(cpm_example
    spdlog)
```

```cmake 24:25
cmake_minimum_required(VERSION 3.18)

project(cpm_example)

set(CMAKE_CXX_STANDARD 17)

set(CPM_DOWNLOAD_VERSION 0.27.2) 
set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")

if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
    message(STATUS "Downloading CPM.cmake")
    file(DOWNLOAD https://github.com/TheLartians/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake ${CPM_DOWNLOAD_LOCATION})
endif()

include(${CPM_DOWNLOAD_LOCATION})

CPMAddPackage(
    NAME spdlog
    GITHUB_REPOSITORY gabime/spdlog
    VERSION 1.7.0)
    
add_executable(cpm_example src/main.cpp)

target_link_libraries(cpm_example
    spdlog)
```

```cmake 
cmake_minimum_required(VERSION 3.18)

project(cpm_example)

set(CMAKE_CXX_STANDARD 17)

set(CPM_DOWNLOAD_VERSION 0.27.2) 
set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")

if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
    message(STATUS "Downloading CPM.cmake")
    file(DOWNLOAD https://github.com/TheLartians/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake ${CPM_DOWNLOAD_LOCATION})
endif()

include(${CPM_DOWNLOAD_LOCATION})

CPMAddPackage(
    NAME spdlog
    GITHUB_REPOSITORY gabime/spdlog
    VERSION 1.7.0)
    
add_executable(cpm_example src/main.cpp)

target_link_libraries(cpm_example
    spdlog)
```

</CodeSurfer>

---

# I am envy of cargo
More examples of CPM Google Suite

<CodeSurfer theme={vsDark}>

```cmake 
CPMAddPackage(
  NAME benchmark
  GITHUB_REPOSITORY google/benchmark
  VERSION 1.4.1
  OPTIONS
    "BENCHMARK_ENABLE_TESTING Off"
)

if (benchmark_ADDED)
  set_target_properties(benchmark PROPERTIES CXX_STANDARD 17) 
endif()

add_executable(Benchmark performance_tests.cpp)
target_link_libraries(Benchmark benchmark)
set_target_properties(Benchmark PROPERTIES CXX_STANDARD 17)

CPMAddPackage(
  NAME googletest
  GITHUB_REPOSITORY google/googletest
  GIT_TAG release-1.8.1
  VERSION 1.8.1
  OPTIONS
      "INSTALL_GTEST OFF"
      "gtest_force_shared_crt"
)

add_executable(TestSuite unit_tests.cpp)
target_link_libraries(TestSuite gtest gtest_main gmock)
set_target_properties(TestSuite PROPERTIES CXX_STANDARD 17)

```

```cmake  5:6
CPMAddPackage(
  NAME benchmark
  GITHUB_REPOSITORY google/benchmark
  VERSION 1.4.1
  OPTIONS
    "BENCHMARK_ENABLE_TESTING Off"
)

if (benchmark_ADDED)
  set_target_properties(benchmark PROPERTIES CXX_STANDARD 17) 
endif()

add_executable(Benchmark performance_tests.cpp)
target_link_libraries(Benchmark benchmark)
set_target_properties(Benchmark PROPERTIES CXX_STANDARD 17)

CPMAddPackage(
  NAME googletest
  GITHUB_REPOSITORY google/googletest
  GIT_TAG release-1.8.1
  VERSION 1.8.1
  OPTIONS
      "INSTALL_GTEST OFF"
      "gtest_force_shared_crt"
)

add_executable(TestSuite unit_tests.cpp)
target_link_libraries(TestSuite gtest gtest_main gmock)
set_target_properties(TestSuite PROPERTIES CXX_STANDARD 17)

```

```cmake  9:11
CPMAddPackage(
  NAME benchmark
  GITHUB_REPOSITORY google/benchmark
  VERSION 1.4.1
  OPTIONS
    "BENCHMARK_ENABLE_TESTING Off"
)

if (benchmark_ADDED)
  set_target_properties(benchmark PROPERTIES CXX_STANDARD 17) 
endif()

add_executable(Benchmark performance_tests.cpp)
target_link_libraries(Benchmark benchmark)
set_target_properties(Benchmark PROPERTIES CXX_STANDARD 17)

CPMAddPackage(
  NAME googletest
  GITHUB_REPOSITORY google/googletest
  GIT_TAG release-1.8.1
  VERSION 1.8.1
  OPTIONS
      "INSTALL_GTEST OFF"
      "gtest_force_shared_crt"
)

add_executable(TestSuite unit_tests.cpp)
target_link_libraries(TestSuite gtest gtest_main gmock)
set_target_properties(TestSuite PROPERTIES CXX_STANDARD 17)

```

```cmake  12:15
CPMAddPackage(
  NAME benchmark
  GITHUB_REPOSITORY google/benchmark
  VERSION 1.4.1
  OPTIONS
    "BENCHMARK_ENABLE_TESTING Off"
)

if (benchmark_ADDED)
  set_target_properties(benchmark PROPERTIES CXX_STANDARD 17) 
endif()

add_executable(Benchmark performance_tests.cpp)
target_link_libraries(Benchmark benchmark)
set_target_properties(Benchmark PROPERTIES CXX_STANDARD 17)

CPMAddPackage(
  NAME googletest
  GITHUB_REPOSITORY google/googletest
  GIT_TAG release-1.8.1
  VERSION 1.8.1
  OPTIONS
      "INSTALL_GTEST OFF"
      "gtest_force_shared_crt"
)

add_executable(TestSuite unit_tests.cpp)
target_link_libraries(TestSuite gtest gtest_main gmock)
set_target_properties(TestSuite PROPERTIES CXX_STANDARD 17)

```

```cmake  19:24
CPMAddPackage(
  NAME benchmark
  GITHUB_REPOSITORY google/benchmark
  VERSION 1.4.1
  OPTIONS
    "BENCHMARK_ENABLE_TESTING Off"
)

if (benchmark_ADDED)
  set_target_properties(benchmark PROPERTIES CXX_STANDARD 17) 
endif()

add_executable(Benchmark performance_tests.cpp)
target_link_libraries(Benchmark benchmark)
set_target_properties(Benchmark PROPERTIES CXX_STANDARD 17)

CPMAddPackage(
  NAME googletest
  GITHUB_REPOSITORY google/googletest
  GIT_TAG release-1.8.1
  VERSION 1.8.1
  OPTIONS
      "INSTALL_GTEST OFF"
      "gtest_force_shared_crt"
)

add_executable(TestSuite unit_tests.cpp)
target_link_libraries(TestSuite gtest gtest_main gmock)
set_target_properties(TestSuite PROPERTIES CXX_STANDARD 17)

```

```cmake
CPMAddPackage(
  NAME benchmark
  GITHUB_REPOSITORY google/benchmark
  VERSION 1.4.1
  OPTIONS
    "BENCHMARK_ENABLE_TESTING Off"
)

if (benchmark_ADDED)
  set_target_properties(benchmark PROPERTIES CXX_STANDARD 17) 
endif()

add_executable(Benchmark performance_tests.cpp)
target_link_libraries(Benchmark benchmark)
set_target_properties(Benchmark PROPERTIES CXX_STANDARD 17)

CPMAddPackage(
  NAME googletest
  GITHUB_REPOSITORY google/googletest
  GIT_TAG release-1.8.1
  VERSION 1.8.1
  OPTIONS
      "INSTALL_GTEST OFF"
      "gtest_force_shared_crt"
)

add_executable(TestSuite unit_tests.cpp)
target_link_libraries(TestSuite gtest gtest_main gmock)
set_target_properties(TestSuite PROPERTIES CXX_STANDARD 17)

```

</CodeSurfer>

---


# I am envy of cargo
More examples of CPM Boost

<CodeSurfer theme={vsDark}>

```cmake

CPMFindPackage(
  NAME Boost
  GITHUB_REPOSITORY Orphis/boost-cmake
  VERSION 1.67.0
  FIND_PACKAGE_ARGUMENTS "COMPONENTS system"
)

target_link_libraries(CPMExampleBoost PRIVATE Boost::system pthread)

```

```cmake 4

CPMFindPackage(
  NAME Boost
  GITHUB_REPOSITORY Orphis/boost-cmake
  VERSION 1.67.0
  FIND_PACKAGE_ARGUMENTS "COMPONENTS system"
)

target_link_libraries(CPMExampleBoost PRIVATE Boost::system pthread)

```

```cmake 6

CPMFindPackage(
  NAME Boost
  GITHUB_REPOSITORY Orphis/boost-cmake
  VERSION 1.67.0
  FIND_PACKAGE_ARGUMENTS "COMPONENTS system"
)

target_link_libraries(CPMExampleBoost PRIVATE Boost::system pthread)

```

```cmake 9

CPMFindPackage(
  NAME Boost
  GITHUB_REPOSITORY Orphis/boost-cmake
  VERSION 1.67.0
  FIND_PACKAGE_ARGUMENTS "COMPONENTS system"
)

target_link_libraries(CPMExampleBoost PRIVATE Boost::system pthread)

```

```cmake

CPMFindPackage(
  NAME Boost
  GITHUB_REPOSITORY Orphis/boost-cmake
  VERSION 1.67.0
  FIND_PACKAGE_ARGUMENTS "COMPONENTS system"
)

target_link_libraries(CPMExampleBoost PRIVATE Boost::system pthread)

```

</CodeSurfer>

---

# I am envy of Cargo

<Steps>
    <li>Wasn't really hard was it ?</li>
    <li>For minimum amount of work, we relieved ourselves from package setups. </li>
    <li>CPM is not the only facility that enables this. We have other options like conan or vcpkg</li>
    <li>Cmake also has a command called external_project</li>
    <li>There are some shortcomings though, we don't get easy version control with those</li>
    <li>Removing cache requires you to download the libs again</li>
    <li>Try to solve this as an exercise :)</li>
</Steps>

---

# I'm envy of built in code generation 
# (Derive)

---

# I'm envy of built in code generation 

<Steps>
    <li>Rust have a powerful type system with polymorphism but no inheritence.</li>
    <li>Then how they are doing polymorphism ?</li>
    <li>Answer is Generics and Traits</li>
    <li>You can think of the Generics as Templates and Traits as pure virtual Interfaces</li>
    <li>Since the beggining rust had some capabilty to auto implement some traits</li>
</Steps>

---

# I'm envy of built in code generation 

<CodeSurfer theme={vsDark}>

```rust

#[derive(Debug)]
struct Pet {
    name: String,
}

use std::fmt;

struct Pet {
    name: String,
}

impl fmt::Debug for Pet {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Pet { name } => {
                let mut debug_trait_builder = f.debug_struct("Pet");

                let _ = debug_trait_builder.field("name", name);

                debug_trait_builder.finish()
            }
        }
    }
}

```

```rust 3:5

#[derive(Debug)]
struct Pet {
    name: String,
}

use std::fmt;

struct Pet {
    name: String,
}

impl fmt::Debug for Pet {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Pet { name } => {
                let mut debug_trait_builder = f.debug_struct("Pet");

                let _ = debug_trait_builder.field("name", name);

                debug_trait_builder.finish()
            }
        }
    }
}

```

```rust 2

#[derive(Debug)]
struct Pet {
    name: String,
}

use std::fmt;

struct Pet {
    name: String,
}

impl fmt::Debug for Pet {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Pet { name } => {
                let mut debug_trait_builder = f.debug_struct("Pet");

                let _ = debug_trait_builder.field("name", name);

                debug_trait_builder.finish()
            }
        }
    }
}

```

```rust 7:25

#[derive(Debug)]
struct Pet {
    name: String,
}

use std::fmt;

struct Pet {
    name: String,
}

impl fmt::Debug for Pet {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Pet { name } => {
                let mut debug_trait_builder = f.debug_struct("Pet");

                let _ = debug_trait_builder.field("name", name);

                debug_trait_builder.finish()
            }
        }
    }
}

```

```rust 13:25

#[derive(Debug)]
struct Pet {
    name: String,
}

use std::fmt;

struct Pet {
    name: String,
}

impl fmt::Debug for Pet {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Pet { name } => {
                let mut debug_trait_builder = f.debug_struct("Pet");

                let _ = debug_trait_builder.field("name", name);

                debug_trait_builder.finish()
            }
        }
    }
}

```

```rust

#[derive(Debug)]
struct Pet {
    name: String,
}

use std::fmt;

struct Pet {
    name: String,
}

impl fmt::Debug for Pet {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Pet { name } => {
                let mut debug_trait_builder = f.debug_struct("Pet");

                let _ = debug_trait_builder.field("name", name);

                debug_trait_builder.finish()
            }
        }
    }
}

```

</CodeSurfer>

---

# I'm envy of built in code generation

<Steps>
    <li>This is really, really cool</li>
    <li>But until rust 1.15 this is only available for basic traits, that are _not_ user defined </li>
    <li>These were traits like Debug, Copy, Comparision or Clone</li>
    <li>After 1.15 you can use this powerful feature for your own libs</li>
    <li>Let's check the same thing for a popular rust lib serde</li>
</Steps>

---

# I'm envy of built in code generation 

<CodeSurfer theme={vsDark}>

```rust

use serde::{Deserialize, Serialize};
use serde_json::Result;

#[derive(Serialize, Deserialize)]
struct Person {
    name: String,
    age: u8,
    phones: Vec<String>,
}

fn typed_example() -> Result<()> {
    // Some JSON input data as a &str. Maybe this comes from the user.
    let data = r#"
        {
            "name": "John Doe",
            "age": 43,
            "phones": [
                "+44 1234567",
                "+44 2345678"
            ]
        }"#;

    // Parse the string of data into a Person object. 
    let p: Person = serde_json::from_str(data)?;

    // Do things just like with any other Rust data structure.
    println!("Please call {} at the number {}", p.name, p.phones[0]);

    Ok(())
}

```

```rust 15:22

use serde::{Deserialize, Serialize};
use serde_json::Result;

#[derive(Serialize, Deserialize)]
struct Person {
    name: String,
    age: u8,
    phones: Vec<String>,
}

fn typed_example() -> Result<()> {
    // Some JSON input data as a &str. Maybe this comes from the user.
    let data = r#"
        {
            "name": "John Doe",
            "age": 43,
            "phones": [
                "+44 1234567",
                "+44 2345678"
            ]
        }"#;

    // Parse the string of data into a Person object. 
    let p: Person = serde_json::from_str(data)?;

    // Do things just like with any other Rust data structure.
    println!("Please call {} at the number {}", p.name, p.phones[0]);

    Ok(())
}

```

```rust 6:10

use serde::{Deserialize, Serialize};
use serde_json::Result;

#[derive(Serialize, Deserialize)]
struct Person {
    name: String,
    age: u8,
    phones: Vec<String>,
}

fn typed_example() -> Result<()> {
    // Some JSON input data as a &str. Maybe this comes from the user.
    let data = r#"
        {
            "name": "John Doe",
            "age": 43,
            "phones": [
                "+44 1234567",
                "+44 2345678"
            ]
        }"#;

    // Parse the string of data into a Person object. 
    let p: Person = serde_json::from_str(data)?;

    // Do things just like with any other Rust data structure.
    println!("Please call {} at the number {}", p.name, p.phones[0]);

    Ok(())
}

```

```rust 5

use serde::{Deserialize, Serialize};
use serde_json::Result;

#[derive(Serialize, Deserialize)]
struct Person {
    name: String,
    age: u8,
    phones: Vec<String>,
}

fn typed_example() -> Result<()> {
    // Some JSON input data as a &str. Maybe this comes from the user.
    let data = r#"
        {
            "name": "John Doe",
            "age": 43,
            "phones": [
                "+44 1234567",
                "+44 2345678"
            ]
        }"#;

    // Parse the string of data into a Person object. 
    let p: Person = serde_json::from_str(data)?;

    // Do things just like with any other Rust data structure.
    println!("Please call {} at the number {}", p.name, p.phones[0]);

    Ok(())
}

```

```rust 24:28

use serde::{Deserialize, Serialize};
use serde_json::Result;

#[derive(Serialize, Deserialize)]
struct Person {
    name: String,
    age: u8,
    phones: Vec<String>,
}

fn typed_example() -> Result<()> {
    // Some JSON input data as a &str. Maybe this comes from the user.
    let data = r#"
        {
            "name": "John Doe",
            "age": 43,
            "phones": [
                "+44 1234567",
                "+44 2345678"
            ]
        }"#;

    // Parse the string of data into a Person object. 
    let p: Person = serde_json::from_str(data)?;

    // Do things just like with any other Rust data structure.
    println!("Please call {} at the number {}", p.name, p.phones[0]);

    Ok(())
}

```

```rust

use serde::{Deserialize, Serialize};
use serde_json::Result;

#[derive(Serialize, Deserialize)]
struct Person {
    name: String,
    age: u8,
    phones: Vec<String>,
}

fn typed_example() -> Result<()> {
    // Some JSON input data as a &str. Maybe this comes from the user.
    let data = r#"
        {
            "name": "John Doe",
            "age": 43,
            "phones": [
                "+44 1234567",
                "+44 2345678"
            ]
        }"#;

    // Parse the string of data into a Person object. 
    let p: Person = serde_json::from_str(data)?;

    // Do things just like with any other Rust data structure.
    println!("Please call {} at the number {}", p.name, p.phones[0]);

    Ok(())
}

```

</CodeSurfer>

---

# I'm envy of built in code generation 

<Steps>
    <li>This is really, really, reaaaaly cool</li>
    <li>How can we achieve the same thing with C++ ?</li>
    <li>Approach is to use a tool to modify the source</li>
    <li>Best place to run this tool is from the build system</li>
    <li>We don't want to add generated file into version control</li>
    <li>So tool should create the new file and build system should only build that file</li>
    <li>Once again our tool of choice is Cmake</li>
    <li>And lets make a "Deriver" using our trusty Python Interpreter</li>
</Steps>

---

# Codegen (Build system)

Here is the Cmake file

<CodeSurfer theme={vsDark}>

```cmake

cmake_minimum_required(VERSION 3.17)
project(generator)

set(CMAKE_CXX_STANDARD 17)

set(py_cmd ${CMAKE_CURRENT_SOURCE_DIR}/deriver.py)

add_custom_command(
        OUTPUT
            ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h
        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/aHeaderFile.h
        COMMAND python ${py_cmd} -i ${CMAKE_CURRENT_SOURCE_DIR}/aHeaderFile.h -o ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
)

add_executable(generator main.cpp ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h)

```

```cmake 9:15

cmake_minimum_required(VERSION 3.17)
project(generator)

set(CMAKE_CXX_STANDARD 17)

set(py_cmd ${CMAKE_CURRENT_SOURCE_DIR}/deriver.py)

add_custom_command(
        OUTPUT
            ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h
        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/aHeaderFile.h
        COMMAND python ${py_cmd} -i ${CMAKE_CURRENT_SOURCE_DIR}/aHeaderFile.h -o ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
)

add_executable(generator main.cpp ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h)

```

```cmake 12

cmake_minimum_required(VERSION 3.17)
project(generator)

set(CMAKE_CXX_STANDARD 17)

set(py_cmd ${CMAKE_CURRENT_SOURCE_DIR}/deriver.py)

add_custom_command(
        OUTPUT
            ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h
        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/aHeaderFile.h
        COMMAND python ${py_cmd} -i ${CMAKE_CURRENT_SOURCE_DIR}/aHeaderFile.h -o ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
)

add_executable(generator main.cpp ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h)

```

```cmake 13

cmake_minimum_required(VERSION 3.17)
project(generator)

set(CMAKE_CXX_STANDARD 17)

set(py_cmd ${CMAKE_CURRENT_SOURCE_DIR}/deriver.py)

add_custom_command(
        OUTPUT
            ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h
        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/aHeaderFile.h
        COMMAND python ${py_cmd} -i ${CMAKE_CURRENT_SOURCE_DIR}/aHeaderFile.h -o ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
)

add_executable(generator main.cpp ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h)

```

```cmake 7

cmake_minimum_required(VERSION 3.17)
project(generator)

set(CMAKE_CXX_STANDARD 17)

set(py_cmd ${CMAKE_CURRENT_SOURCE_DIR}/deriver.py)

add_custom_command(
        OUTPUT
            ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h
        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/aHeaderFile.h
        COMMAND python ${py_cmd} -i ${CMAKE_CURRENT_SOURCE_DIR}/aHeaderFile.h -o ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
)

add_executable(generator main.cpp ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h)

```

```cmake

cmake_minimum_required(VERSION 3.17)
project(generator)

set(CMAKE_CXX_STANDARD 17)

set(py_cmd ${CMAKE_CURRENT_SOURCE_DIR}/deriver.py)

add_custom_command(
        OUTPUT
            ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h
        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/aHeaderFile.h
        COMMAND python ${py_cmd} -i ${CMAKE_CURRENT_SOURCE_DIR}/aHeaderFile.h -o ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
)

add_executable(generator main.cpp ${CMAKE_CURRENT_BINARY_DIR}/generated_header.h)

```

</CodeSurfer>

---


# Codegen (Build system)

<CodeSurfer theme={vsDark}>

```python

#!/usr/bin/python

import getopt
import sys
import shutil


def generate_file(input_file, output_file):
    shutil.copyfile(input_file, output_file)


def main(argv):
    input_file = ''
    output_file = ''
    try:
        opts, args = getopt.getopt(argv, "hi:o:", ["ifile=", "ofile="])
    except getopt.GetoptError:
        print 'deriver.py -i <inputfile> -o <outputfile>'
        sys.exit(2)
    for opt, arg in opts:
        if opt in ("-i", "--ifile"):
            input_file = arg
        elif opt in ("-o", "--ofile"):
            output_file = arg
    print 'Input file is "', input_file
    print 'Output file is "', output_file
    generate_file(input_file, output_file)


if __name__ == "__main__":
    main(sys.argv[1:])

```

```python 9:10

#!/usr/bin/python

import getopt
import sys
import shutil


def generate_file(input_file, output_file):
    shutil.copyfile(input_file, output_file)


def main(argv):
    input_file = ''
    output_file = ''
    try:
        opts, args = getopt.getopt(argv, "hi:o:", ["ifile=", "ofile="])
    except getopt.GetoptError:
        print 'deriver.py -i <inputfile> -o <outputfile>'
        sys.exit(2)
    for opt, arg in opts:
        if opt in ("-i", "--ifile"):
            input_file = arg
        elif opt in ("-o", "--ofile"):
            output_file = arg
    print 'Input file is "', input_file
    print 'Output file is "', output_file
    generate_file(input_file, output_file)


if __name__ == "__main__":
    main(sys.argv[1:])

```

</CodeSurfer>

---

# I'm envy of built in code generation

<Steps>
    <li>Now we can run stuff when a source has changed. </li>
    <li>You can modify the source as you like, your binary only depends on generated source </li>
    <li>Before I offend you, I don't claim this is the best way of doing this.</li>
    <li>It is just a simple way :)</li>
    <li>As a exercise, try to enwrap this in a loop for all the found resources</li>
    <li>There are great extensibility in cmake on when your scripts needs to be run</li>
    <li>If you are so inclined you can run them just before link or after some event</li>
    <li>Check the official docs for extra info</li>
</Steps>

---

# I'm envy of linear typesystem of Rust

---


# I'm envy of linear typesystem of Rust

<Steps>
    <li>Okay great but what is a linear typesystem ? </li>

> Values belonging to a linear type must be used exactly once: like the world, they can not be duplicated or destroyed. Such values require no reference counting or garbage collection
***
Linear types can change the world!, Philip Wadler
  
 
</Steps>

---

# I'm envy of linear typesystem of Rust

<CodeSurfer theme={vsDark}>


```rust

let x = vec![1, 2, 3];
let y = x;           
println!("{:?}", x); 
pritnln!("{:?}", y);  

```

```rust 2

let x = vec![1, 2, 3];
let y = x;           
println!("{:?}", x); 
pritnln!("{:?}", y);  

```

```rust 3

let x = vec![1, 2, 3];
let y = x;           
println!("{:?}", x); 
pritnln!("{:?}", y);  

```

```rust 4:5

let x = vec![1, 2, 3];
let y = x;           
println!("{:?}", x); 
pritnln!("{:?}", y);  

```

```rust 4:5

let x = vec![1, 2, 3];
let y = x;           
println!("{:?}", x); // ERROR: use of moved value x
pritnln!("{:?}", y); // OK 

```


```rust 3:5

let x = vec![1, 2, 3];
let y = x;           // x is not copied but moved here
println!("{:?}", x); // ERROR: use of moved value x
pritnln!("{:?}", y); // OK 

```

</CodeSurfer>

---

# I'm envy of linear typesystem of Rust

Why this is soo important ?

<img src={meme} 
style={{
    width: '800px',
    height: '800px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  }}
/>


---

# I'm envy of linear typesystem of Rust

Lets see what is going on in depths of C++

<CodeSurfer theme={vsDark}>

```cpp

istream_sequence<std::string> in{std::cin};

std::string result;
for (const auto& token: in) {
   result.append(token); 
}

```

```cpp 2

istream_sequence<std::string> in{std::cin};

std::string result;
for (const auto& token: in) {
   result.append(token); 
}

```cpp 7

istream_sequence<std::string> in{std::cin};

std::string result;
for (const auto& token: in) {
   result.append(token); 
}

```

```cpp 6:8

istream_sequence<std::string> in{std::cin};

std::string result;
for (const auto& token: in) {
   result.append(token); 
}

```

```cpp

istream_sequence<std::string> in{std::cin};

const auto result = accumulate(in, string{});

```

```cpp

template <typename InputIt, typename T>
T accumulate(InputIt first, InputIt last, T init)
{
    while (first != last) { 
        init = init + *first; ++first;
    }
    return init;
}

```

```cpp 6

template <typename InputIt, typename T>
T accumulate(InputIt first, InputIt last, T init)
{
    while (first != last) { 
        init = init + *first; ++first;
    }
    return init;
}

```

</CodeSurfer>

---

# I'm Envy of Linear typesystem of rust

This is what is happening

<img src={clones} 
style={{
    width: '600px',
    height: '600px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  }}
/>

---

# I'm Envy of Linear typesystem of rust

From C++ 20 and onwards

<CodeSurfer theme={vsDark}>

```cpp 

template <typename InputIt, typename T>
T accumulate(InputIt first, InputIt last, T init)
{
    while (first != last) {
        init = std::move(init) + *first; ++first;
    }
    return init;
}

```

```cpp 6

template <typename InputIt, typename T>
T accumulate(InputIt first, InputIt last, T init)
{
    while (first != last) {
        init = std::move(init) + *first; ++first;
    }
    return init;
}

```

</CodeSurfer>

---

# I'm Envy of Linear typesystem of rust


<Steps>
    <li>Okay you got my attention</li>
    <li>Lets implement similiar functionality with C++ 20 Concepts</li>
    <li>We will let compiler to do our job !!</li>
    <li>Why stop at a concept ? Lets create a wrapper also !!</li>
</Steps>

---

# I'm Envy of Linear typesystem of rust


<CodeSurfer theme={vsDark}>

```cpp 

namespace detail {
template <typename T, typename U> constexpr bool linear_usable_as_v =
        std::is_nothrow_constructible_v<T, U> and
        std::is_nothrow_assignable_v<T&, U> and 
        std::is_nothrow_convertible_v<U, T>;
}

namespace detail {
template <typename T, typename U> constexpr bool linear_unusable_as_v =
        not std::is_constructible_v<T, U> and
        not std::is_assignable_v<T&, U> and 
        not std::is_convertible_v<U, T>;
}

template <typename T> 
concept Linear =
    std::is_nothrow_destructible_v<T> and 
    detail::linear_usable_as<T, T> and
    detail::linear_usable_as<T, T&&> and
    
    detail::linear_unusable_as<T, T&> and 
    detail::linear_unusable_as<T, const T&> and 
    detail::linear_unusable_as<T, const T>;

Linear ptr = std::make_unique<person>(); // OK 
Linear str = ”Hello world”s; // ERROR

```

```cpp 16:24

namespace detail {
template <typename T, typename U> constexpr bool linear_usable_as_v =
        std::is_nothrow_constructible_v<T, U> and
        std::is_nothrow_assignable_v<T&, U> and 
        std::is_nothrow_convertible_v<U, T>;
}

namespace detail {
template <typename T, typename U> constexpr bool linear_unusable_as_v =
        not std::is_constructible_v<T, U> and
        not std::is_assignable_v<T&, U> and 
        not std::is_convertible_v<U, T>;
}

template <typename T> 
concept Linear =
    std::is_nothrow_destructible_v<T> and 
    detail::linear_usable_as<T, T> and
    detail::linear_usable_as<T, T&&> and
    
    detail::linear_unusable_as<T, T&> and 
    detail::linear_unusable_as<T, const T&> and 
    detail::linear_unusable_as<T, const T>;

Linear ptr = std::make_unique<person>(); // OK 
Linear str = ”Hello world”s; // ERROR

```

```cpp 2:7

namespace detail {
template <typename T, typename U> constexpr bool linear_usable_as_v =
        std::is_nothrow_constructible_v<T, U> and
        std::is_nothrow_assignable_v<T&, U> and 
        std::is_nothrow_convertible_v<U, T>;
}

namespace detail {
template <typename T, typename U> constexpr bool linear_unusable_as_v =
        not std::is_constructible_v<T, U> and
        not std::is_assignable_v<T&, U> and 
        not std::is_convertible_v<U, T>;
}

template <typename T> 
concept Linear =
    std::is_nothrow_destructible_v<T> and 
    detail::linear_usable_as<T, T> and
    detail::linear_usable_as<T, T&&> and
    
    detail::linear_unusable_as<T, T&> and 
    detail::linear_unusable_as<T, const T&> and 
    detail::linear_unusable_as<T, const T>;

Linear ptr = std::make_unique<person>(); // OK 
Linear str = ”Hello world”s; // ERROR

```

```cpp 9:14

namespace detail {
template <typename T, typename U> constexpr bool linear_usable_as_v =
        std::is_nothrow_constructible_v<T, U> and
        std::is_nothrow_assignable_v<T&, U> and 
        std::is_nothrow_convertible_v<U, T>;
}

namespace detail {
template <typename T, typename U> constexpr bool linear_unusable_as_v =
        not std::is_constructible_v<T, U> and
        not std::is_assignable_v<T&, U> and 
        not std::is_convertible_v<U, T>;
}

template <typename T> 
concept Linear =
    std::is_nothrow_destructible_v<T> and 
    detail::linear_usable_as<T, T> and
    detail::linear_usable_as<T, T&&> and
    
    detail::linear_unusable_as<T, T&> and 
    detail::linear_unusable_as<T, const T&> and 
    detail::linear_unusable_as<T, const T>;

Linear ptr = std::make_unique<person>(); // OK 
Linear str = ”Hello world”s; // ERROR

```


```cpp 16:24

namespace detail {
template <typename T, typename U> constexpr bool linear_usable_as_v =
        std::is_nothrow_constructible_v<T, U> and
        std::is_nothrow_assignable_v<T&, U> and 
        std::is_nothrow_convertible_v<U, T>;
}

namespace detail {
template <typename T, typename U> constexpr bool linear_unusable_as_v =
        not std::is_constructible_v<T, U> and
        not std::is_assignable_v<T&, U> and 
        not std::is_convertible_v<U, T>;
}

template <typename T> 
concept Linear =
    std::is_nothrow_destructible_v<T> and 
    detail::linear_usable_as<T, T> and
    detail::linear_usable_as<T, T&&> and
    
    detail::linear_unusable_as<T, T&> and 
    detail::linear_unusable_as<T, const T&> and 
    detail::linear_unusable_as<T, const T>;

Linear ptr = std::make_unique<person>(); // OK 
Linear str = ”Hello world”s; // ERROR

```

```cpp 26:27

namespace detail {
template <typename T, typename U> constexpr bool linear_usable_as_v =
        std::is_nothrow_constructible_v<T, U> and
        std::is_nothrow_assignable_v<T&, U> and 
        std::is_nothrow_convertible_v<U, T>;
}

namespace detail {
template <typename T, typename U> constexpr bool linear_unusable_as_v =
        not std::is_constructible_v<T, U> and
        not std::is_assignable_v<T&, U> and 
        not std::is_convertible_v<U, T>;
}

template <typename T> 
concept Linear =
    std::is_nothrow_destructible_v<T> and 
    detail::linear_usable_as<T, T> and
    detail::linear_usable_as<T, T&&> and
    
    detail::linear_unusable_as<T, T&> and 
    detail::linear_unusable_as<T, const T&> and 
    detail::linear_unusable_as<T, const T>;

Linear ptr = std::make_unique<person>(); // OK 
Linear str = ”Hello world”s; // ERROR

```

</CodeSurfer>

---

# I'm Envy of Linear typesystem of rust


<CodeSurfer theme={vsDark}>

```cpp

class linear_wrapper { 
    
public:
    
    linear_wrapper(T&& value)
    : m_value{std::move(value)}
    {

    }
    
private:
    
    T m_value;
};

```

```cpp

class linear_wrapper { 

public:
    
    linear_wrapper(T&& value)
    : m_value{std::move(value)}
    {

    }

    linear_wrapper(const linear_wrapper&) = delete;
    linear_wrapper(linear_wrapper&&) = default; // noexcept

    linear_wrapper& operator=(const linear_wrapper&) = delete;
    linear_wrapper& operator=(linear_wrapper&&) = default; // noexcept
    
private:
    
    T m_value;
};

```


```cpp

class linear_wrapper { 

public:
    
    linear_wrapper(T&& value)
    : m_value{std::move(value)}
    {

    }

    linear_wrapper(const linear_wrapper&) = delete;
    linear_wrapper(linear_wrapper&&) = default; // noexcept

    linear_wrapper& operator=(const linear_wrapper&) = delete;
    linear_wrapper& operator=(linear_wrapper&&) = default; // noexcept


    [[nodiscard]] T&& get() && noexcept {
        return std::move(value);
    }
    
private:
    
    T m_value;
};

```

</CodeSurfer>

---

## The End

Got any questions ?

---

